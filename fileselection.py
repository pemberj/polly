"""
Polly

fileselection

Contains functions that search the shrek filesystem for relevant files, either
KPF L1 FITS files or mask/drift files generated by Polly
"""

from __future__ import annotations

from datetime import datetime
from glob import glob

from astropy.io import fits


try:
    from polly.log import logger
    from polly.kpf import ORDERLETS, TIMESOFDAY
    from polly.parsing import parse_date_string, parse_filename
except ImportError:
    from log import logger
    from kpf import ORDERLETS, TIMESOFDAY
    from parsing import parse_date_string, parse_filename



def find_L1_etalon_files(
    date: str,
    timeofday: str,
    masters: bool,
    pp: str = "",
    ) -> str | list[str]:
    """
    Locates relevant L1 files for a given date and time of day. At the moment
    it loops through all files and looks at the "OBJECT" keyword in their
    headers.
    
    TODO: Don't just take every matching frame! There are three "blocks" of
          three etalon frames taken every morning (and evening?). Should take
          only the single block that is closest to the SoCal observations.
    TODO: Use a database lookup (on shrek) to select files?
    """
    
    assert timeofday in TIMESOFDAY
    
    if masters:
        files = glob(
            f"/data/kpf/masters/{date}/"+\
               f"kpf_{date}_master_arclamp_"+\
                   f"autocal-etalon-all-{timeofday}_L1.fits"
               )
        try:
            assert len(files) == 1
        except AssertionError:
            logger.info(f"{pp}{len(files)} files found")
            return None

        with open(files[0], mode="rb") as _f:
            try:
                object = fits.getval(_f, "OBJECT")
                if "etalon" in object.lower():
                    return files[0]
            except FileNotFoundError as e:
                logger.error(f"{pp}{e}")
                return None
            except OSError as e:
                logger.error(f"{pp}{e}")
                return None
            
    all_files: list[str] = glob(f"/data/kpf/L1/{date}/*.fits")
    
    out_files: list[str] = []
    
    for f in all_files:
        object = fits.getval(f, "OBJECT")
        if "etalon" in object.lower():
            timeofday = object.split("-")[-1]
            if timeofday == timeofday:
                out_files.append(f)
                
    return out_files


def find_mask(
    masks: list[str],
    datestr: str | None = None,
    date: datetime | None = None,
    timeofday: str = "eve",
    orderlet: str = "SCI2",
    ) -> str:
    """
    Find a single mask matching the input criteria. To be used to locate the
    reference mask for a drift analysis.
    """
    
    if (datestr is None and date is None) or (datestr and date):
        print("Exactly one of `datestr` or `date` must be specified")
        
    if date:
        assert isinstance(date, datetime)
        
    if datestr:
        date = parse_date_string(datestr)
        
    assert orderlet in ORDERLETS
    assert timeofday in TIMESOFDAY
        
    for m in masks:
        mdate, mtimeofday, morderlet = parse_filename(m)
        if mdate == date and mtimeofday == timeofday and morderlet == orderlet:
            return m
        
    
def select_masks(
    masks: list[str],
    min_date: datetime | None = None,
    max_date: datetime | None = None,
    timeofday: str | list[str] | None = None,
    orderlet:  str | list[str] | None = None,
    ) -> list[str]:
    """
    Find all masks in an input list that match the given criteria.
    """
    
    if isinstance(orderlet, str):
        orderlet = [orderlet]
    for ol in orderlet:
        assert ol in [*ORDERLETS, None]
        
    if isinstance(timeofday, str):
        timeofday = [timeofday]
    for tod in timeofday:
        assert tod in [*TIMESOFDAY, None]
    
    # Start with the full list of masks
    valid_masks = masks
    
    # Then progressively keep only the matching masks
    if min_date:
        valid_masks =\
            [m for m in valid_masks if parse_filename(m).date >= min_date]
        
    if max_date:
        valid_masks =\
            [m for m in valid_masks if parse_filename(m).date <= max_date]
    
    if timeofday:
        valid_masks =\
            [m for m in valid_masks\
                if parse_filename(m).timeofday in timeofday]
        
    if orderlet:
        valid_masks =\
            [m for m in valid_masks if parse_filename(m).orderlet in orderlet]
    
    # Only the matching masks are left
    if not valid_masks:
        print("No matching masks found!")
        return None
    
    return valid_masks
