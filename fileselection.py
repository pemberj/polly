"""
Polly

fileselection

Contains functions that search the shrek filesystem for relevant files, either
KPF L1 FITS files or mask/drift files generated by Polly
"""

from __future__ import annotations

from datetime import datetime
from glob import glob

from astropy.io import fits


try:
    from polly.log import logger
    from polly.kpf import ORDERLETS, TIMESOFDAY
    from polly.parsing import parse_date_string, parse_filename
except ImportError:
    from log import logger
    from kpf import ORDERLETS, TIMESOFDAY
    from parsing import parse_date_string, parse_filename



def find_L1_etalon_files(
    DATE: str,
    TIMEOFDAY: str,
    masters: bool,
    pp: str = "",
    ) -> str | list[str]:
    """
    Locates relevant L1 files for a given date and time of day. At the moment
    it loops through all files and looks at the "OBJECT" keyword in their
    headers.
    
    TODO:
     - Don't just take every matching frame! There are three "blocks" of three
       etalon frames taken every morning (and evening?). Should take only the
       single block that is closest to the SoCal observations.
     - Use a database lookup (on shrek) to select files
    """
    
    if masters:
        files = glob(
            f"/data/kpf/masters/{DATE}/"+\
               f"kpf_{DATE}_master_arclamp_"+\
                   f"autocal-etalon-all-{TIMEOFDAY}_L1.fits"
               )
        try:
            assert len(files) == 1
        except AssertionError:
            logger.info(f"{pp}{len(files)} files found")
            return None

        with open(files[0], mode="rb") as _f:
            try:
                object = fits.getval(_f, "OBJECT")
                if "etalon" in object.lower():
                    return files[0]
            except FileNotFoundError as e:
                logger.error(f"{pp}{e}")
                return None
            except OSError as e:
                logger.error(f"{pp}{e}")
                return None
            
    all_files: list[str] = glob(f"/data/kpf/L1/{DATE}/*.fits")
    
    out_files: list[str] = []
    
    for f in all_files:
        object = fits.getval(f, "OBJECT")
        if "etalon" in object.lower():
            timeofday = object.split("-")[-1]
            if timeofday == TIMEOFDAY:
                out_files.append(f)
                
    return out_files


def find_mask(
    masks: list[str],
    datestr: str | None = None,
    date: datetime | None = None,
    timeofday: str = "eve",
    orderlet: str = "SCI2",
    ) -> str:
    
    if (datestr is None and date is None) or (datestr and date):
        print("Either datestr or date must be specified, not both")
        
    if date:
        assert isinstance(date, datetime)
        
    if datestr:
        date = parse_date_string(datestr)
        
    for m in masks:
        mdate, mtimeofday, morderlet = parse_filename(m)
        if mdate == date and mtimeofday == timeofday and morderlet == orderlet:
            return m
        
    
def select_masks(
    masks: list[str],
    min_date: datetime | None = None,
    max_date: datetime | None = None,
    timeofday: str | list[str] | None = None,
    orderlet:  str | list[str] | None = None,
    ) -> list[str]:
    """
    """
    
    if isinstance(orderlet, str):
        orderlets = [orderlet]
        for ol in orderlets:
            assert ol in [*ORDERLETS, None]
        
    if isinstance(timeofday, str):
        timesofday = [timeofday]
        for tod in timesofday:
            assert tod in [*TIMESOFDAY, None]
    
    valid_masks = masks
    
    if min_date:
        valid_masks =\
            [m for m in valid_masks if parse_filename(m).date >= min_date]
        
    if max_date:
        valid_masks =\
            [m for m in valid_masks if parse_filename(m).date <= max_date]
    
    if timeofday:
        valid_masks =\
            [m for m in valid_masks\
                if parse_filename(m).timeofday in timesofday]
        
    if orderlet:
        valid_masks =\
            [m for m in valid_masks if parse_filename(m).orderlet in orderlets]
    
    return valid_masks
